{\rtf1\ansi\ansicpg1252\cocoartf1404\cocoasubrtf340
{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fnil\fcharset0 Menlo-Regular;\f2\fnil\fcharset0 Menlo-Bold;
\f3\fnil\fcharset0 LucidaGrande;}
{\colortbl;\red255\green255\blue255;\red63\green110\blue116;\red92\green38\blue153;\red46\green13\blue110;
\red170\green13\blue145;\red196\green26\blue22;\red38\green71\blue75;\red230\green230\blue230;\red53\green53\blue53;
}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid1\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listname ;}\listid1}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}}
\margl1440\margr1440\vieww13140\viewh16580\viewkind1
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\b\fs36 \cf0 Lab 1 \'96\'a0Using Location APIs\

\fs22 Assigned: \
Due:
\b0\fs36 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\fs22 \cf0 \
In this lab, you will start by developing a small standalone application to measure location data, and then you will integrate location API support into Anteater.\
\
Labs in 6.S062 consist of a number of 
\b tasks
\b0 , each of which has one or more 
\b deliverables
\b0 .  This lab has 2 sections, the first dealing with the standalone app and the second with anteater.\
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\b \cf0 Section I :  Location APIs and Exploring the Power Drain vs Accuracy Tradeoff\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\b0 \cf0 \
In Section I, you will use a standalone iOS app called PositionLogger.\
\
The PositionLogger app allows you to log position data at different accuracies, using different positioning technologies, including WiFi, Cellular, and GPS.\
\
We've provided most of the code for the PostitionLogger App, including a simple UI for choosing a desired accuracy, as well as an interface to email a log file of recorded positions out of the app.  The main UI of the PostionLogger is shown below:\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\qc\partightenfactor0
\cf0 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\qc\partightenfactor0
\cf0 {{\NeXTGraphic 9460B43A-D59C-4FEA-BB87-D411D48E7F6D.png \width3160 \height4240
}¬}\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\qc\partightenfactor0
\cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural\partightenfactor0
\cf0 \
Your job is to implement the calls to the iOS CoreLocation API to request location updates at the desired accuracy, and then compare the accuracy and power drain of the different approaches.\
\

\b Getting Started\
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\b0 \cf0 1. Download the PositionLogger source code by doing a git clone of XXX.  (If you are unfamiliar with git, read the brief tutorial at XXX.)  \
\
2. Open the PositionLogger.xcodeproj file and compile and run the app, either on your device or in the simulator (use any of the iPhone simulators.)  It should show a screen like what you see above.  Clicking on the Start button should cause it to a recording state, but it won't actually be writing location data until you add the code to record location.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural\partightenfactor0

\b \cf0 iOS Location Primer
\b0 \
\
The primary way that location is accessed on iOS use though the CoreLocation class CLLocationManager ({\field{\*\fldinst{HYPERLINK "https://developer.apple.com/library/ios/documentation/CoreLocation/Reference/CLLocationManager_Class/"}}{\fldrslt https://developer.apple.com/library/ios/documentation/CoreLocation/Reference/CLLocationManager_Class/}}).  Using this class you can request location updates at a certain accuracy, and also configure the accuracy with which data is created.\
\
In the PostionLogger app, the main screen is an instance of a ViewController object (as specified in ViewController.m.) iOS creates one instance of the ViewController class for us when the application is initialized, because the Main.storyboard file, which we chose as the main storyboard for the app in the Info.plist file, specifies that the initial view for the app should be an instance of ViewController. \
\
In the 
\f1 viewDidLoad
\f0  method of ViewController.m, we've already created an instance of a CLLocationManager object for you to use and initialized some of the relevant properties of it.  These are the lines at the beginning of the 
\f1 viewDidLoad
\f0  method:\
\
\pard\tx220\tx720\pardeftab529\li720\fi-720\pardirnatural\partightenfactor0
\ls1\ilvl0
\f1 \cf0 {\listtext	1.	}\CocoaLigature0     \cf2 _locmgr\cf0  = [[\cf3 CLLocationManager\cf0  \cf4 alloc\cf0 ] \cf4 init\cf0 ];\
\ls1\ilvl0\CocoaLigature1 {\listtext	2.	}\CocoaLigature0     [\cf2 _locmgr\cf0  \cf4 requestAlwaysAuthorization\cf0 ];\
\ls1\ilvl0\CocoaLigature1 {\listtext	3.	}\CocoaLigature0     \cf2 _locmgr\cf0 .\cf3 allowsBackgroundLocationUpdates\cf0  = \cf5 TRUE\cf0 ;\
\ls1\ilvl0\CocoaLigature1 {\listtext	4.	}\CocoaLigature0     \cf2 _locmgr\cf0 .\cf3 delegate\cf0  = \cf5 self\cf0 ;\
\ls1\ilvl0\CocoaLigature1 {\listtext	5.	}\CocoaLigature0     \cf2 _locmgr\cf0 .\cf3 distanceFilter\cf0  = \cf3 kCLDistanceFilterNone\cf0 ;\
\ls1\ilvl0\CocoaLigature1 {\listtext	6.	}\CocoaLigature0     [\cf2 _locmgr\cf0  \cf4 disallowDeferredLocationUpdates\cf0 ];\
\pard\tx529\pardeftab529\pardirnatural\partightenfactor0
\cf0 \

\f0 You can read about the details of the methods in the CLLocationManager documentation, but the gist of this code is that we are requesting that:\
\
Lines 2 & 3:  Location updates be delivered all them time, even when the app is the in background (we have also added an entry to the "Required Background Modes" dictionary of the Info.plist file in the project to allow this to work).\
\
Line 4: The LocationManager will call methods indicating the arrival of new data on our class (we are the "delegate" of the LocationManager).\
\
Line 5: We want location updates whenever they are available (no matter how little the phone has moved).\
\
Line 6:  We want iOS to deliver location updates to us immediately, not batch them together.s \
\
Note that the settings in line 5 & 6 may have negative implications on the battery life of the device, but they will allow us to get the highest fidelity data for this lab.\
\

\b\fs28 Task 1
\b0  \'96 
\b Capture Location Data
\b0 \

\fs22 \
The goal of this first task is to log location data to a file and perform some simple analysis of the data.\
\
To acquire the log, you will need to modify the PositionLogger app to start capturing location samples when the "Start" button is tapped.  Open the ViewController.m file.  We have implemented most of this class for you -- scroll down and find the 
\f1 hitRecordStopButton
\f0  method:\
\

\f1 -(\cf5 IBAction\cf0 )hitRecordStopButton:(\cf3 UIButton\cf0  *)b \{\
    \cf5 if\cf0  (!\cf2 _isRecording\cf0 ) \{\
        [\cf5 self\cf0 .\cf2 accuracyControl\cf0  \cf4 setEnabled\cf0 :\cf5 FALSE\cf0 ];\
        [b \cf4 setTitle\cf0 :\cf6 @"Stop"\cf0  \cf4 forState\cf0 :\cf4 UIControlStateNormal\cf0 ];\
        \cf2 _isRecording\cf0  = \cf5 TRUE\cf0 ;\
        [\cf5 self\cf0 .\cf2 recordingIndicator\cf0  \cf4 startAnimating\cf0 ];\
        [\cf5 self\cf0  \cf7 startRecordingLocationWithAccuracy\cf0 :(\cf2 LocationAccuracy\cf0 )\
              [\cf5 self\cf0 .\cf2 accuracyControl\cf0  \cf4 selectedSegmentIndex\cf0 ]];\
    \} \cf5 else\cf0  \{\
        [\cf5 self\cf0 .\cf2 accuracyControl\cf0  \cf4 setEnabled\cf0 :\cf5 TRUE\cf0 ];\
        [b \cf4 setTitle\cf0 :\cf6 @"Start"\cf0  \cf4 forState\cf0 :\cf4 UIControlStateNormal\cf0 ];\
        \cf2 _isRecording\cf0  = \cf5 FALSE\cf0 ;\
        [\cf5 self\cf0 .\cf2 recordingIndicator\cf0  \cf4 stopAnimating\cf0 ];\
        [\cf5 self\cf0  \cf7 stopRecordingLocationWithAccuracy\cf0 ];\
\
    \}\
\}\
\

\f0 This method calls 
\f1 \cf7 startRecordingLocationWithAccuracy 
\f0 or\cf0  
\f1 \cf7 stopRecordingLocationWithAccuracy 
\f0 \cf0 as appropriate.  You need to implement the body of these methods.    \
\
\pard\tx529\pardeftab529\pardirnatural\partightenfactor0

\b \cf0 1.1 Implement 
\f2 \cf7 startRecordingLocationWithAccuracy\

\f0 \cf0 \
\pard\tx529\pardeftab529\pardirnatural\partightenfactor0

\f1\b0 \cf7 startRecordingLocationWithAccuracy 
\f0 \cf0 should set the 
\f1 desiredAccuracy
\f0  property of the 
\f1 _locMgr
\f0  object  to the appropriate accuracy based on the supplied value of the 
\f1 acc
\f0  argument.   Note that iOS does not explicitly allow an application to request GPS, WiFi, or Cellular positioning -- instead it provides the following constants to choose from:\
\

\f1 \cf5 extern\cf0  \cf5 const\cf0  \cf3 CLLocationAccuracy\cf0  kCLLocationAccuracyBestForNavigation;\
\cf5 extern\cf0  \cf5 const\cf0  \cf3 CLLocationAccuracy\cf0  kCLLocationAccuracyBest;\
\cf5 extern\cf0  \cf5 const\cf0  \cf3 CLLocationAccuracy\cf0  kCLLocationAccuracyNearestTenMeters;\
\cf5 extern\cf0  \cf5 const\cf0  \cf3 CLLocationAccuracy\cf0  kCLLocationAccuracyHundredMeters;\
\cf5 extern\cf0  \cf5 const\cf0  \cf3 CLLocationAccuracy\cf0  kCLLocationAccuracyKilometer;\
\cf5 extern\cf0  \cf5 const\cf0  \cf3 CLLocationAccuracy\cf0  kCLLocationAccuracyThreeKilometers;\

\f0 \
For  each of the three settings in the app, you should choose one of these constants that you think is most appropriate for 
\f1 desiredAccuracy. 
\f0 Once you have set the desired accuracy, call 
\f1 \cf4 startUpdatingLocation\cf0  
\f0 on the 
\f1 _locMgr
\f0  object.
\f1 \

\f0 \
\pard\tx529\pardeftab529\pardirnatural\partightenfactor0

\b \cf0 \
1.2 Implement 
\f2 \cf7 stopRecordingLocationWithAccuracy\
\
\pard\tx529\pardeftab529\pardirnatural\partightenfactor0

\f1\b0 \cf7 stopRecordingLocationWithAccuracy
\f0  \cf0 just needs to call  \cf7  
\f1 \cf4 stopUpdatingLocation\cf0  
\f0 on the 
\f1 _locMgr
\f0  object.  (It's OK to call this function on the 
\f1 _locMgr
\f0  even if it is already stopped.)
\f1 \
\
\pard\tx529\pardeftab529\pardirnatural\partightenfactor0

\f0\b \cf0 1.3 Implementing
\f2  didUpdateLocations\
\
\pard\tx529\pardeftab529\pardirnatural\partightenfactor0

\f0\b0 \cf0 The next step is to implement code to log position updates as they arrive.  We've already set up the instance of ViewController.m as the 
\i delegate
\i0  of the _locMgr object.  This means that it will call the 
\f1 didUpdateLocations
\f0  method on ViewController.m when a location update is available.  You need to implement this method.   Its signature is as follows:\
\
 
\f1 - (\cf5 void\cf0 )locationManager:(\cf3 CLLocationManager\cf0  *)manager\
     didUpdateLocations:(\cf3 NSArray\cf0 <\cf3 CLLocation\cf0  *> *)locations;\
\

\f0\b \cb8 Tip
\b0 : You can find this definition in the CLLocationManager.h iOS header file, which you can open by typing 
\f3 \uc0\u8984 
\f0 -shift-O and then entering the first few characters of the file's name.\
\pard\tx529\pardeftab529\pardirnatural\partightenfactor0

\f2\b \cf0 \cb1 \
\pard\tx529\pardeftab529\pardirnatural\partightenfactor0

\f0\b0 \cf0 Your implementation of 
\f1 didUpdateLocations
\f0  should iterate through the locations and log them to the file.  We've provided a method 
\f1 \cf7 logLineToDataFile
\f0 \cf0  that logs an NSString object to the log file (which you can then email to yourself using the email button.)  \
\
In the later part of this lab, you're going to visualize and analyze this data, so you'll need log at least the timestamp of the reading, the latitude, the longitude, the horizontal accuracy, and the battery level of the device.  To get the current battery level you can call:\
\

\f1     [[\cf3 UIDevice\cf0  \cf4 currentDevice\cf0 ] \cf4 batteryLevel\cf0 ];\
\pard\tx529\pardeftab529\pardirnatural\partightenfactor0

\f2\b \cf0 \
\pard\tx529\pardeftab529\pardirnatural\partightenfactor0

\f0\b0 \cf0 We'd also suggest logging the course (bearing) and speed attributes from the supplied CLLocation objects.  For time, we suggest just converting the 
\f1 timestamp
\f0  (
\f1 NSDate
\f0 ) object in each 
\f1 CLLocation
\f0  to a Unix time stamp by calling 
\f1 [location.\cf3 timestamp\cf0  \cf4 timeIntervalSince1970\cf0 ]
\f0  on it.\
\
Note that we currently write a header at the start of the log file in the 
\f1 viewDidLoad
\f0  method:\
\

\f1     [\cf5 self\cf0  \cf7 logLineToDataFile\cf0 :\cf6 @"Time,Lat,Lon,Altitude,\
			Accuracy,Heading,Speed,Battery\\n"\cf0 ];\

\f0 \
You may want to modify this depending on what you choose to log.\
\
\pard\tx529\pardeftab529\pardirnatural\partightenfactor0

\b \cf0 1.4 Capturing some data\
\
\pard\tx529\pardeftab529\pardirnatural\partightenfactor0

\b0 \cf0 We've implemented the rest of the application to allow you to capture data from it and email data to yourself.  Verify that it works by attempting to log some data with GPS accuracy on your phone and email it to yourself (note that location updates can be simulated in the simulator, but that the simulator does not support the email interface properly).\
\
In the rest of this part of the lab you'll collect some data outdoors and compare the different location methods, looking at accuracy and power of the different techniques.\
\
There are no deliverables for this task.\
\
\pard\tx529\pardeftab529\pardirnatural\partightenfactor0

\b\fs26 \cf0 Task 2  \'96\'a0Compare the Accuracy of the Location Methods\
\
\pard\tx529\pardeftab529\pardirnatural\partightenfactor0

\b0\fs22 \cf0 In this exercise, you will walk from the corner of Vassar and Main to the corner of Vassar and Mass Ave three times.  For each walk, you'll run the app at a different location accuracy, and compare the difference in the overall estimated distance and plot the points on a map.\
\
See this map for the route you will walk:\
\
https://www.google.com/maps/d/edit?mid=zcVI9zKum-vM.kVzhADJu9RDg&usp=sharing\
\
According to Google, the length of this route is .306 miles (492.5 meters).  \
\
Specifically, for each of the three accuracy settings:\
	1.  Start at one end of the route\
	2.  If you have other apps on the phone, we suggest disabling location services for any\
		that are currently using location services, in Settings->Privacy.  This is important \
		because other apps using location services can cause your app to receive\
		a finer granularity of location data that you requested.\
	3.  Open the app, set to the desired accuracy setting, and start recording\
	4.  Walk the route (you can close the app or leave it open)\
	5.  At the end of the route, start recording, and email yourself the log file.	\
	6.  Clear the log\
\
Once you have the three log files, your task is to compute the "connect the dots" distance for each path, and to plot each path on a map.\
\
The "connect the dots" distance of a path is just the sum of the distances between every consecutive point.  Each point is a latitude/longitude pair, which represents a point on the surface of the earth.  For points that are close together, Euclidian distance is a close approximation of the actual distance, but for points that are far apart, a straight line can be quite far from the true distance between these points, which follows an arc on the surface of the Earth.  The typical way to estimate this distance is to assume the Earth is a sphere (it isn't exactly spherical but pretty close), and to use the haversine formula to compute the distance between the two points:\
\pard\tx529\pardeftab529\pardirnatural\partightenfactor0

\fs24 \cf0 \CocoaLigature1 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\qc\partightenfactor0
\cf0 {{\NeXTGraphic CodeCogsEqn.png \width8550 \height720
}¬}\
\pard\tx390\tx730\pardeftab529\li1143\fi-763\pardirnatural\qc\partightenfactor0

\f1\fs22 \cf0 \CocoaLigature0 \
\pard\tx529\pardeftab529\pardirnatural\partightenfactor0

\f0 \cf0 \
where the two points are (lat1,lon1) and (lat2,lon2) and r is the Earth's radius (6371 km).  Be sure to convert lat/lon to radians (multiply by Pi and divide by 180.0 ) before using built-in trigonometric functions.\
\
(see {\field{\*\fldinst{HYPERLINK "https://en.wikipedia.org/wiki/Haversine_formula"}}{\fldrslt https://en.wikipedia.org/wiki/Haversine_formula}})\
\
For each of the three logs, compute the "connect the dots" distance between all points in the trace using the haversine formula.  How does it compare to the measure .306 miles?\
\
In addition, plot each of the three files on a map.  We've provided a script, csv2kml.py, that will convert a csv file with a header line that includes "Lat" and "Lon" fields into a KML file that you can view on Google Earth or import into Google My Maps ({\field{\*\fldinst{HYPERLINK "https://mapsengine.google.com/map/"}}{\fldrslt https://mapsengine.google.com/map/}}).  If you'd prefer, you may visualize these files using some other method than Google Maps / Google Earth.\
\
The deliverables for this task are the connect-the-dots distance you computed for the three different walks, as well as a plot of each of the three walks you did on a map.\
\
\
\pard\tx529\pardeftab529\pardirnatural\partightenfactor0

\b\fs26 \cf0 Task 3 \'96\'a0Compare the Battery Drain of the Location Methods\
\pard\tx529\pardeftab529\pardirnatural\partightenfactor0

\b0\fs22 \cf0 \
For this task, you will compare the battery drain of the three different location accuracy settings.   To do this, you'll need to start logging and let the app run for several hours (4 hours should be long enough), and then compare the battery level and the rate of drain while the app runs.\
\
For each of the three accuracy settings:\
	1.  Fully charge the phone\
	2.  If you have other apps on the phone, we suggest disabling location services for any\
		that are currently using location services, in Settings->Privacy.  \
		Also, enable Low Power Mode in Settings->Battery.\
	3.  Open the app, set to the desired accuracy setting, and start recording\
	4.  Turn off the screen and do not use the phone for 4 hours.  \
		The app will continue to record in the background.  \
	5.  Stop recording and email yourself the file.\
	6.  Clear the log.\
\
Once you have the three log files, make a plot of the battery level of each over time, by using the time and battery level fields in the file.  You can make your plot which whichever tool you like:  Google Charts, Excel, pyplot, etc.\
\
The deliverable for this task is the graph of the battery drain of the three different location methods.  Note that if you don't have cellular service on the phone, running with cellular accuracy may produce results different than you expect!\
\

\b\fs28 Section 2 \'96 Building the Anteater Compass\

\b0\fs22 \
In this part of the lab, you'll work with the Anteater app add location-based features.\
 \
Recall that the Anteater App is a crowdsourced sensor data collection app, where users earn points for collecting sensor data from nearby sensors.  In the Anteater app, mobile devices are the 
\i anteaters
\i0 , and the sensors are the 
\i anthills
\i0 .\
\
In later labs you'll work on the code to connect to the anthills, but for the second part of this lab, your job is to implement the compass UI in Anteater, as shown in the screenshot below.  \
\
\pard\tx529\pardeftab529\pardirnatural\qc\partightenfactor0

\fs24 \cf0 \CocoaLigature1 {{\NeXTGraphic Screen Shot 2016-02-04 at 5.48.21 PM.png \width3210 \height5680
}¬}\pard\tx529\pardeftab529\pardirnatural\qc\partightenfactor0
\cf0 \
\
\pard\tx529\pardeftab529\pardirnatural\partightenfactor0

\fs22 \cf0 In this interface, the orange arrow points the user what direction they should turn/walk to move towards the selected Anthill. \
\
To compute the direction this arrow should point, you need to measure the angle between the users current position (represented by a lat/lon point), and the destination anthill.  The conventional way to do this is to model the earth as a sphere, and measure the angle of vector from the origin to the destination along the shortest path (the "great circle path").     The trigonometry to do this is fairly hairy, but thanks to the Internet the formula is easy to look up.  Here's the Objective-C code to do this:\

\fs24 \
\pard\tx529\pardeftab529\pardirnatural\partightenfactor0

\f1\fs22 \cf4 \CocoaLigature0 double angleRadians = atan2\cf0 (\cf4 sin\cf0 (lon2-lon1)*\cf4 cos\cf0 (lat2), \cf4 cos\cf0 (lat1)*\cf4 sin\cf0 (lat2)-\cf4 sin\cf0 (lat1)*\cf4 cos\cf0 (lat2)*\cf4 cos\cf0 (lon2-lon1);\
\

\f0 Here (lat1,lon1) is the starting point, and (lat2,lon2) is the ending point.  In this formula, lat and lon need to be converted to radians, and the result is in radians.\
\
If you are curious about the derivation of this, there's a good explanation half way down this post:\
\
http://mathforum.org/library/drmath/view/55417.html\
\
From the article:  "
\i \cf9 \CocoaLigature1 Let's define three unit vectors, each in the direction of the line from the center of the earth to a point on the surface: N in the direction of the north pole, A in the direction of the initial point, and B in the direction of the final point on the course. Then the bearing we seek is the angle between the plane containing N and A, and the plane containing A and B. Thus it equals the angle between vectors perpendicular to these planes, namely, NxA and BxA.
\i0 \cf0 \CocoaLigature0 "\
\
Computing this is straightforward trigonometry, although the explanation for the use of the atan2 function is non-obvious.\
\
Once you've figured out the angle between the user's current location and the destination anthill, you need to figure out the orientation of the phone relative to North, and subtract that angle from the bearing to the destination, as shown in this diagram:\
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\qc\partightenfactor0

\fs24 \cf0 \CocoaLigature1 {{\NeXTGraphic Pasted Graphic 1.pdf \width5080 \height6900
}¬}\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\qc\partightenfactor0
\cf0 \
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\fs22 \cf0 Putting it all together, once you compute the two angles, subtract \uc0\u952 
\fs18 2 
\fs22 from
\fs18  
\fs22 \uc0\u952 
\fs18 1
\fs22 , and set the rotation of the compass graphic to that value.
\fs18    
\fs22 (To see why we subtract \uc0\u952 
\fs18 2
\fs22 , imagine that the phone is already pointed in the direction of the destination
\fs18 . 
\fs22  In that case, \uc0\u952 
\fs18 1
\fs22 \uc0\u8776 \u952 
\fs18 2.
\fs22 )The next task will walk you through implementing the steps.\
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\b\fs26 \cf0 Task 4 - Rotate the Compass Needle Image \
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\b0\fs22 \cf0 There are three subtasks: first, get the user's location and compute \uc0\u952 
\fs18 1 
\fs22 (based on the currently selected anthill);  second, compute the orientation of the phone and compute \uc0\u952 
\fs18 2
\fs22 ; third, set the orientation of the needle image.\
\
We've created CompassViewController.m for you, but you will need to write most of the code.  We've configured the UI to have a reference to the needle image.\
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\b \cf0 4.1  Compute \uc0\u952 
\fs18 1\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\b0 \cf0 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\fs22 \cf0 \CocoaLigature0 You can compute  \CocoaLigature1 \uc0\u952 
\fs18 1
\fs22  using the above formula once you have both the user's location and the location of a target anthill.  In the code we've given you, there is an _anthills array that is loaded when the view appears.  We've provided a method called 
\f1 \CocoaLigature0 curSelectedLocation 
\f0 that will return the location of the currently selected anthill (when anthills is non-null/has been loaded.)\
\
When the user changes the currently selected anthill, the following method will be called:\
\

\f1 - (\cf5 void\cf0 )pickerView:(UIPickerView *)pickerView didSelectRow:(NSInteger)row inComponent:(NSInteger)component\
\pard\tx529\pardeftab529\pardirnatural\partightenfactor0
\cf0 \{\
\
    \
\}\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0 \cf0 \
You should fill in the body of this with code to recompute the angle to the current anthill.  You may want to define a helper function to do this, because you will also want to recompute when the user's location changes.\
\
We've also initialized a 
\f1 CLLocationManager
\f0  object and request that it start providing location updates to CompassViewController.  You'll need to fill in the body of the 
\f1 didUpdateLocations 
\f0 method to get the user's current location, and update the current estimated angle to the selected anthill (using the same function you defined when the anthill changed.)\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\b\fs26 \cf0 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\fs22 \cf0 \CocoaLigature1 4.2  Compute \uc0\u952 
\fs18 2\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\fs26 \cf0 \CocoaLigature0 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\b0\fs22 \cf0 Modern iPhones have a magnetometer that can measure the orientation of the phone with respect to the Earth's magnetic field (its 
\i heading
\i0 ).   An app can be requested to be notified of the phone's heading as it changes by calling the 
\f1 startUpdatingHeading
\f0  method on the 
\f1 CLLocationManager 
\f0 object.  We have already done this for you in CompassViewController.m's viewDidLoad method.  You should fill in the body of the 
\f1  \
\
- (\cf5 void\cf0 )locationManager:(CLLocationManager *)manager didUpdateHeading:(CLHeading *)newHeading\

\f0  
\f1 \

\f0 method with code to compute \CocoaLigature1 \uc0\u952 
\fs18 1 
\fs22 -
\fs18  
\fs22 \uc0\u952 
\fs18 2.  
\fs22 You can access the current heading of the device (in radians) by accessing the 
\f1 trueHeading 
\f0 property of the provided 
\f1 newHeading
\f0  object.
\b\fs26 \CocoaLigature0 \
\
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\fs22 \cf0 \CocoaLigature1 4.3  Rotate the Needle by \uc0\u952 
\fs18 1 
\fs22 -
\fs18  
\fs22 \uc0\u952 
\fs18 2\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\fs26 \cf0 \CocoaLigature0 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\b0\fs22 \cf0 Whenever you get an update to the device's location or orientation, or a new anthill is selected, you should update the rotation of the needle.  The needle is a 
\f1 UIView
\f0  that is available as a property of  
\f1 CompassViewController
\f0 .  In iOS you can rotate (and scale/transform) any view simply by setting the value of the 
\f1 transform
\f0  field of the view. This field  is an instance of a 
\f1 \cf3 CGAffineTransform 
\f0 \cf0 struct
\f1 \cf3 . 
\f0 \cf0 You can create a transform that specifies a particular rotation by calling the 
\f1 CGAffineTransformMakeRotation 
\f0 function
\f1 .
\f0   Create a transform and assign it to the 
\f1 needle
\f0  property of your 
\f1 CompassViewController. 
\f0 The UI will automatically rotate the view to the correct orientation.\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\b \cf0 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\b0 \cf0 In addition, set the text of the 
\f1 distanceLabel
\f0  label to the distance to the current anthill and the text of the 
\f1 headingLabel
\f0  label to \CocoaLigature1 \uc0\u952 
\fs18 1 
\fs22 -
\fs18  
\fs22 \uc0\u952 
\fs18 2. 
\fs22 \CocoaLigature0 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\b \cf0 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\b0 \cf0 The deliverable for this task is a working implementation of the Anteater compass.
\b \
\pard\tx529\pardeftab529\pardirnatural\partightenfactor0

\b0 \cf0 \
\pard\tx529\pardeftab529\pardirnatural\partightenfactor0

\b \cf0 Submission Instructions\
\
\pard\tx529\pardeftab529\pardirnatural\partightenfactor0

\b0 \cf0 A complete lab will consist of:\
\
- Estimated distances for the three methods from Task 2, as well as maps of the points.\
- Plots of the battery drain for Task 3\
- A working compass demonstration for Task 4}